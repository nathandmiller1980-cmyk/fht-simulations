"""
complex_kahler_manifold
=======================

This module defines the ``ComplexKahlerManifold`` class, a simple two dimensional
Kähler manifold equipped with a complex structure and a fractal-like Hermitian
metric.  The primary goal of this class is to support simulations of parallel
transport and holonomy on a manifold whose geometry varies in a
self‑similar fashion across scales.

The code in this module is adapted from several iterations of fractal holonomy
experiments carried out in the chat session.  It exposes the core
functionality used in those experiments so that they can be reproduced from a
single Python file.

Usage
-----
The class can be instantiated by specifying a grid resolution, a level of
fractal refinement and a scale for the curvature variations.  Once
constructed, you can call ``compute_holonomy_complex`` with a loop function
and an initial vector to measure the holonomy around a closed path.

Example::

    from complex_kahler_manifold import ComplexKahlerManifold

    # create a manifold
    cm = ComplexKahlerManifold(size=200, fractal_level=4, curvature_scale=0.3)
    # define a simple loop
    def circle_loop(t):
        return 0.5 + 0.5j + 0.4 * np.exp(2j * np.pi * t)
    # run holonomy computation
    phase, mat, vecs, pts = cm.compute_holonomy_complex(circle_loop, (1+0j, 1-0j), steps=300)
    print("phase", phase)

The module can also be executed directly as a script to run a default
demonstration of holonomy on a single loop (see the ``__main__`` section).

This code requires only standard numerical Python libraries (NumPy and
Matplotlib); SciPy is not necessary.
"""

import numpy as np
import matplotlib.pyplot as plt


class ComplexKahlerManifold:
    """A 2D Kähler manifold with complex structure and fractal Hermitian metric.

    The manifold is discretized on a square grid in the complex plane.  A
    fractal-like Hermitian metric is generated by superposing complex waves
    of increasing frequency.  Connection forms are computed numerically to
    support parallel transport in the complexified tangent space.

    Parameters
    ----------
    size : int
        Resolution of the square grid along each axis.  A larger value
        produces more detailed structure at the expense of increased memory
        usage.
    fractal_level : int
        The number of refinement levels used in constructing the metric.
        Higher values produce more oscillations in the geometry.
    curvature_scale : float
        Overall amplitude of the metric perturbations.  A value of zero
        corresponds to flat space, while larger values induce stronger
        curvature.
    """

    def __init__(self, size: int = 100, fractal_level: int = 3, curvature_scale: float = 0.1) -> None:
        self.size = size
        self.fractal_level = fractal_level
        self.curvature_scale = curvature_scale

        # set up a square grid of complex numbers
        real_axis = np.linspace(-2, 2, size)
        imag_axis = np.linspace(-2, 2, size)
        self.z = real_axis + 1j * imag_axis[:, None]
        self.z_conj = np.conj(self.z)

        # build Hermitian metric component h_zz and its conjugate
        self.h_zz = self._generate_fractal_metric(fractal_level, curvature_scale)
        # Avoid zeros in the metric which lead to singular connection coefficients.  We
        # clip the metric from below by a small epsilon to ensure positive values.
        self.h_zz = np.where(self.h_zz < 1e-8, 1e-8, self.h_zz)
        self.h_zz_conj = np.conj(self.h_zz)

        # compute connection forms for parallel transport
        self.Gamma_z_zz = None
        self.Gamma_z_conj_zz_conj = None
        self.compute_connection_forms()

    def _generate_fractal_metric(self, level: int, scale: float) -> np.ndarray:
        """Generate a fractal-like Hermitian metric component.

        A simple form of fractal metric is produced by summing complex
        exponential waves of increasing frequency.  The weighting of each
        frequency decays as the frequency increases, producing structure at
        multiple scales.  The result is forced to be positive by taking its
        magnitude.

        Parameters
        ----------
        level : int
            Number of refinement levels.
        scale : float
            Scale factor for the amplitude of the waves.

        Returns
        -------
        ndarray
            A 2D array of complex numbers representing the metric component.
        """
        rng = np.random.RandomState(42)  # deterministic seed for reproducibility
        result = np.ones_like(self.z, dtype=np.complex128)
        for l in range(level):
            freq = 2 ** l
            weight = 1.0 / (freq ** 1.5)
            phase1 = rng.uniform(0, 2 * np.pi)
            phase2 = rng.uniform(0, 2 * np.pi)
            # superpose waves in the real and imaginary directions
            result += (
                scale
                * weight
                * (np.exp(1j * freq * np.real(self.z) + phase1)
                   + np.exp(1j * freq * np.imag(self.z) + phase2))
            )
        # ensure positive definiteness by taking absolute value
        return np.abs(result)

    def compute_connection_forms(self) -> None:
        """Compute connection forms for the complex manifold.

        The nonzero components of the Levi‑Civita connection on a Kähler
        manifold are \Gamma^z_{zz} and \Gamma^{\bar{z}}_{\bar{z}\bar{z}}.  In
        this discrete implementation we approximate the derivatives using
        finite differences.
        """
        # compute step sizes along real (x) and imaginary (y) axes
        dx = np.real(self.z[0, 1] - self.z[0, 0])
        dy = np.imag(self.z[1, 0] - self.z[0, 0])
        # compute derivatives with respect to x (real) and y (imaginary) directions
        dh_dy, dh_dx = np.gradient(self.h_zz, dy, dx)
        # convert to complex derivatives with respect to z and z̄
        # using ∂/∂z = 0.5 (∂/∂x - i∂/∂y), ∂/∂\bar{z} = 0.5 (∂/∂x + i∂/∂y)
        dh_zz_dz = 0.5 * (dh_dx - 1j * dh_dy)
        dh_zz_dz_conj = 0.5 * (dh_dx + 1j * dh_dy)
        # ensure no NaNs or infinities in derivatives
        dh_zz_dz = np.nan_to_num(dh_zz_dz, nan=0.0, posinf=0.0, neginf=0.0)
        dh_zz_dz_conj = np.nan_to_num(dh_zz_dz_conj, nan=0.0, posinf=0.0, neginf=0.0)
        # compute connection forms
        self.Gamma_z_zz = np.nan_to_num(dh_zz_dz / self.h_zz, nan=0.0, posinf=0.0, neginf=0.0)
        self.Gamma_z_conj_zz_conj = np.nan_to_num(dh_zz_dz_conj / self.h_zz_conj, nan=0.0, posinf=0.0, neginf=0.0)

    def get_connection(self, z: complex) -> dict:
        """Interpolate the connection forms at an arbitrary complex point.

        Parameters
        ----------
        z : complex
            The point at which to sample the connection coefficients.

        Returns
        -------
        dict
            A dictionary containing the connection forms at the given point.
        """
        # find the closest grid index to the given point
        idx = np.argmin(np.abs(self.z - z))
        row, col = np.unravel_index(idx, self.z.shape)
        return {
            "Gamma_z_zz": self.Gamma_z_zz[row, col],
            "Gamma_z_conj_zz_conj": self.Gamma_z_conj_zz_conj[row, col],
        }

    def parallel_transport_complex(
        self,
        curve,
        initial_vector: tuple[complex, complex],
        steps: int = 100,
    ) -> tuple[tuple[np.ndarray, np.ndarray], np.ndarray]:
        """Perform complex parallel transport along a parametric curve.

        Parameters
        ----------
        curve : callable
            A function taking a parameter t \in [0,1] and returning a complex
            coordinate z(t).
        initial_vector : tuple of complex numbers
            The initial tangent vector components (v_z, v_{\bar{z}}).
        steps : int
            Number of discretization steps along the curve.

        Returns
        -------
        (v_z, v_z_conj) : tuple of ndarray
            Arrays of complex vector components along the path.
        points : ndarray
            The sampled points z(t) along the curve.
        """
        t_span = np.linspace(0.0, 1.0, steps)
        points = np.array([curve(t) for t in t_span], dtype=np.complex128)
        # initialize arrays for the transported vector components
        v_z = np.zeros(steps, dtype=np.complex128)
        v_z_conj = np.zeros(steps, dtype=np.complex128)
        v_z[0], v_z_conj[0] = initial_vector

        for i in range(steps - 1):
            dt = t_span[i + 1] - t_span[i]
            z = points[i]
            # compute derivative dz/dt
            if i == 0:
                dzdt = (points[i + 1] - z) / dt
            else:
                dzdt = (points[i + 1] - points[i - 1]) / (2 * dt)
            dz_conjdt = np.conj(dzdt)

            # obtain connection coefficients
            Gamma = self.get_connection(z)
            gamma_z = Gamma["Gamma_z_zz"]
            gamma_z_conj = Gamma["Gamma_z_conj_zz_conj"]

            # compute derivative of the tangent vector components
            dv_zdt = -gamma_z * v_z[i] * dzdt
            dv_z_conjdt = -gamma_z_conj * v_z_conj[i] * dz_conjdt

            # update using Euler integration
            v_z[i + 1] = v_z[i] + dv_zdt * dt
            v_z_conj[i + 1] = v_z_conj[i] + dv_z_conjdt * dt

        return (v_z, v_z_conj), points

    def compute_holonomy_complex(
        self,
        loop,
        initial_vector: tuple[complex, complex],
        steps: int = 100,
    ) -> tuple[complex, np.ndarray, tuple[np.ndarray, np.ndarray], np.ndarray]:
        """Compute the holonomy around a closed loop in the complex plane.

        Parameters
        ----------
        loop : callable
            A function from [0,1] to the complex plane describing the closed path.
        initial_vector : tuple of complex numbers
            The initial tangent vector (v_z, v_{\bar{z}}) to be transported.
        steps : int
            Number of discretization points along the loop.

        Returns
        -------
        holonomy_phase : complex
            The ratio v_z(final) / v_z(initial), giving the complex phase
            acquired by the holomorphic component of the tangent vector.
        holonomy_matrix : ndarray
            A 2 × 2 diagonal unitary matrix representing the holonomy on the
            complexified tangent space.
        (v_z, v_z_conj) : tuple of ndarray
            Transported vector components sampled along the loop.
        points : ndarray
            Points along the loop.
        """
        (v_z, v_z_conj), points = self.parallel_transport_complex(loop, initial_vector, steps)
        # compute ratio of final to initial holomorphic component
        if np.abs(v_z[0]) > 1e-12:
            holonomy_phase = v_z[-1] / v_z[0]
        else:
            holonomy_phase = 1.0 + 0j
        # extract the angle and construct a unitary matrix in the holonomy group
        angle = np.angle(holonomy_phase)
        holonomy_matrix = np.array(
            [[np.exp(1j * angle), 0], [0, np.exp(-1j * angle)]], dtype=np.complex128
        )
        return holonomy_phase, holonomy_matrix, (v_z, v_z_conj), points


if __name__ == "__main__":
    # demonstration when run as a script
    cm = ComplexKahlerManifold(size=200, fractal_level=4, curvature_scale=0.2)
    # define a simple closed loop (circle)
    def simple_loop(t: float) -> complex:
        return 0.5 + 0.5j + 0.4 * np.exp(2j * np.pi * t)
    # initial tangent vector components
    initial_vec = (1.0 + 0j, 1.0 - 0j)
    phase, mat, (v_z, v_z_conj), pts = cm.compute_holonomy_complex(simple_loop, initial_vec, steps=300)
    # print summary
    print("Holonomy phase factor:", phase)
    print("Holonomy angle (degrees):", np.degrees(np.angle(phase)))
    print("Holonomy matrix:\n", mat)
    # optional simple plot showing the path and vector transport (real parts)
    plt.figure(figsize=(8, 4))
    plt.title("Complex Parallel Transport Demonstration")
    plt.plot(np.real(pts), np.imag(pts), "k-", label="Loop")
    idx_skip = max(1, len(pts) // 20)
    for i in range(0, len(pts), idx_skip):
        z = pts[i]
        vz = v_z[i]
        plt.quiver(np.real(z), np.imag(z), np.real(vz), np.imag(vz), scale=10, width=0.005)
    plt.xlabel("Re(z)")
    plt.ylabel("Im(z)")
    plt.legend()
    plt.tight_layout()
    plt.show()